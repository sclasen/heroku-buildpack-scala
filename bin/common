#!/usr/bin/env bash

install_spark(){
  baseDir=$1
  cacheDir=$2
  if [ ! -d "${baseDir}" ]; then echo "Invalid directory to install spark."; return 1 ; fi
  sparkUrl="https://s3.amazonaws.com/heroku-mesos/spark-1.0.0.tar.gz"
  sparkDir="${baseDir}"/spark
  sparkVersion=spark-1.0.0
  sparkTarball="${sparkVersion}".tar.gz
  if [ ! -f "$cacheDir/${sparkTarball}" ] ; then
    curl --silent --location ${sparkUrl} --output $cacheDir/${sparkTarball}
  fi
  tar xfz $cacheDir/${sparkTarball} -C $baseDir
  mv $baseDir/${sparkVersion} $baseDir/spark
}

install_spark_class(){
  baseDir=$1
  sparkUrl="https://s3.amazonaws.com/heroku-mesos/spark-class"
  sparkDir="${baseDir}"/spark
  curl  --silent --location ${sparkUrl} --output $baseDir/spark/bin/spark-class
  chmod +x $baseDir/spark/bin/spark-class
}

install_syslogged(){
  baseDir=$1
  url="https://s3.amazonaws.com/heroku-mesos/syslogged"
  sparkDir="${baseDir}"/spark
  curl  --silent --location ${url} --output $baseDir/spark/syslogged
  chmod +x $baseDir/spark/syslogged
}

copy_log4j_props(){
  baseDir=$1
  buildDir=$2
  echo -n "-----> Copying log4j.properties to spark conf..."
  if [ -f "$buildDir/src/main/resources/log4j.properties" ] ; then
      cp $buildDir/src/main/resources/log4j.properties $baseDir/spark/conf/log4j.properties
      echo "done."
  else
      echo "not found."
  fi
}

copy_spark_env(){
  baseDir=$1
  buildDir=$2
  echo -n  "-----> Copying spark-env.sh to spark conf..."
  if [ -f "$buildDir/src/main/resources/spark-env.sh" ] ; then
      cp $buildDir/src/main/resources/spark-env.sh $baseDir/spark/conf/spark-env.sh
      echo "done."
  else
      echo '#!/usr/bin/env bash' > $baseDir/spark/conf/spark-env.sh
      echo "not found."
  fi
}

write_spark_env(){
  baseDir=$1
  envDir=$2
  whitelist_regex=${3:-''}
  blacklist_regex=${4:-'^(PATH|GIT_DIR|CPATH|CPPATH|LD_PRELOAD|LIBRARY_PATH|JAVA_OPTS|SBT_OPTS|REPO|BUILDPACK_URL)$'}

  if [ -d "$envDir" ]; then
    sparkEnv="${baseDir}"/spark/conf/spark-env.sh
    echo "#!/usr/bin/env bash" > $sparkEnv
    echo -n "SPARK_JAVA_OPTS='" >> $sparkEnv
    for e in $(ls $envDir); do
      echo "$e" | grep -E "$whitelist_regex" | grep -qvE "$blacklist_regex" && echo -n " -D$e=$(cat $envDir/$e)" >> $sparkEnv
      :
    done
    echo "'" >> $sparkEnv
    echo -n "SPARK_CLASSPATH='" >> $sparkEnv
    echo -n $(cat $envDir/SPARK_CLASSPATH) >> $sparkEnv
    echo "'" >> $sparkEnv
    chmod +x $sparkEnv
  fi
}

## SBT 0.10 allows either *.sbt in the root dir, or project/*.scala or .sbt/*.scala
detect_sbt() {
  local ctxDir=$1
  if _has_sbtFile $ctxDir || \
     _has_projectScalaFile $ctxDir || \
     _has_hiddenSbtDir $ctxDir || \
     _has_buildPropertiesFile $ctxDir ; then
    return 0 
  else
    return 1 
  fi
}

is_play() {
  _has_playConfig $1
}

_has_sbtFile() {
  local ctxDir=$1
  test -n "$(find $ctxDir -maxdepth 1 -name '*.sbt' -print -quit)"
}

_has_projectScalaFile() {
  local ctxDir=$1
  test -d $ctxDir/project && test -n "$(find $ctxDir/project -maxdepth 1 -name '*.scala' -print -quit)"
}

_has_hiddenSbtDir() {
  local ctxDir=$1
  test -d $ctxDir/.sbt && test -n "$(find $ctxDir/.sbt -maxdepth 1 -name '*.scala' -print -quit)"
}

_has_buildPropertiesFile() {
  local ctxDir=$1
  test -e $ctxDir/project/build.properties
}

_has_playConfig() {
  local ctxDir=$1
  test -e $ctxDir/conf/application.conf
}

get_supported_sbt_version() {
  local ctxDir=$1
  if _has_buildPropertiesFile $ctxDir; then
    sbtVersionLine="$(grep -P '[ \t]*sbt\.version[ \t]*=' "${ctxDir}"/project/build.properties | sed -E -e 's/[ \t\r\n]//g')"
    sbtVersion=$(expr "$sbtVersionLine" : 'sbt\.version=\(0\.1[1-3]\.[0-9]\)$')
    if [ "$sbtVersion" != 0 ] ; then
      echo "$sbtVersion"
    else
      echo ""
    fi
  else
    echo ""
  fi
}

has_supported_sbt_version() {
  local ctxDir=$1
  local supportedVersion="$(get_supported_sbt_version ${ctxDir})"
  if [ "$supportedVersion" != "" ] ; then
    return 0
  else
    return 1
  fi
}

count_files() {
  local location=$1
  local pattern=$2

  if [ -d ${location} ]; then
    find ${location} -name ${pattern} | wc -l | sed 's/ //g'
  else
    echo "0"
  fi
}

detect_play_lang() {
  local appDir=$1/app
  
  local num_scala_files=$(count_files ${appDir} '*.scala')
  local num_java_files=$(count_files ${appDir} '*.java')

  if   [ ${num_scala_files} -gt ${num_java_files} ] ; then
    echo "Scala"
  elif [ ${num_scala_files} -lt ${num_java_files} ] ; then
    echo "Java"
  else
    echo ""
  fi
}

uses_universal_packaging() {
  local ctxDir=$1
  test -d $ctxDir/target/universal/stage/bin
}

_universal_packaging_procs() {
  local ctxDir=$1
  (cd $ctxDir; find target/universal/stage/bin -type f -executable)
}

_universal_packaging_proc_count() {
  local ctxDir=$1
  _universal_packaging_procs $ctxDir | wc -l
}

universal_packaging_default_web_proc() {
  local ctxDir=$1
  if [ $(_universal_packaging_proc_count $ctxDir) -eq 1 ]; then
    echo "web: $(_universal_packaging_procs $ctxDir) -Dhttp.port=\$PORT"
  fi
}

error() {
    echo " !     $1"
    exit 1
}

cache_copy() {
  rel_dir=$1
  from_dir=$2
  to_dir=$3
  rm -rf $to_dir/$rel_dir
  if [ -d $from_dir/$rel_dir ]; then
    mkdir -p $to_dir/$rel_dir
    cp -pr $from_dir/$rel_dir/. $to_dir/$rel_dir
  fi
}
